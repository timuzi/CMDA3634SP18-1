Part 2
In the HW03 folder you will find two folders, Part1 and Part2. This section concerns the contents of the Part2 folder. Before completing this section, copy the contents of your setupElGamal, ElGamalEncrypt, and ElGamalDecrypt functions completed above to functions.c in this folder.
Cracking the ElGamal Cryptographic System: Once the messages m are encrypted, is very difficult to decrypt them without knowledge of the random number y used in the encryption algorithm, or the secret key x. In the case where we have many messages, finding each y is not feasible and we must instead determine the secret key. This amounts to finding the number x such that
h=gx modp.
Trying to solve this equation by brute force (that is, literally trying every value x) is, luckily, embarrassingly parallel. In this part we will use MPI to accelerate the process of cracking the ElGamal cryptographic system by distributing the job of trying each value of x amoungst many MPI processes.
Q3.1(5 points) Alter the main function so that only rank 0 sets up the ElGamal cryptographic system and then broadcast the public key information to all MPI processes.
Q3.2(15 points) In the main function, all MPI processes currently loop through all values of x. Partition this loop between all MPI processes by setting values for start and end so that all values of x are tested, and the amount of work each MPI process performs is roughly equal.
Parallel performance:
Q4.1(10 points) What would be a good measure of the work performed inside the loop in your program’s main function? Use MPI_Wtime() to compute the total time this loop takes to run inside your program and use your measurement of work to compute your program’s throughput. Output both runtime and throughput quantities at the end of your program.
Q4.2(20 points) Using New River, run your program several times for N = 1,2,4,8,12,16, and 20 MPI processes. You may need to alter your main file to fix the number of bits n, rather than inputting it from the user. Plot the average runtime of your program vs N for a variety of bit lengths. In a separate plot, show the average throughput numbers reported by your program. Give some comments on how this program’s performance scales with the number of MPI processes.
Bonus:(20 points) In practice, we would like to stop searching for the secret key x once it is found, rather than continuing the loop. Alter the loop in your main function so that at regular intervals, say every Ninterval iterations, you determine if the secret key has been found, and stop iterating if so. Remake your runtime and throughput plots in Q3.3. If you averaged over a large number of runs, how much faster would you expect this updated version of the code to run? Does the frequency at which you check if the secret has been found, i.e. the size of Ninterval affect the performance?
